# Authentication Models

Authentication is a major issue in opportunistic networks: how can we be sure that a message was sent by a user, and has not been modified.

The simplest option is to forfeit authentication entirely and trust every node to behave correctly. This is possible for small networks, where the distributor of network nodes can trust every user. However, as the network grows, it becomes a statistical certainty that an untrustworthy person has gained access to the network (even if each user is 99.99% trustworthy, a network with 7000 users has a 50% probability of having an untrusted user). Given that our network is designed to be scalable, this option is infeasible.

Networks which may contain an untrusted user must use measures to prevent this. A common approach is for each user to identify nodes which may be trustworthy or untrustworthy. Social authentication is a common strategy: only 'friends' of users are considered trustworthy. However, for such networks, trust is a transitive property: if I trust my friend and my friend trusts their friend, I must therefore trust the friend of my friend. In real life, this is not always the case. The IRONMAN algorithm takes a different approach by detecting nodes displaying unusual behaviour. These nodes are then marked as untrustworthy. However, this can only detect untrustworthy nodes after they have committed a crime. If the attacker is able to control over 50% of the network (as GHash.IO managed with Bitcoin), they can manipulate the network into believing that the attacker is trustworthy and that other nodes are not. This approach of using heuristics to separate trustworthy and untrustworthy nodes is useful, but still susceptible to attack.

In order to completely mitigate the risk of an attacker (or faulty node) becoming a trusted node, there is only one option: don't trust anyone. The only way to verify that a message actually came from a user is to have some token capable of irrefutably proving that a message was sent by a user. The solution is simple: a public key. Users sign a message with their private key, and anyone with their public key can verify that it came from them. So we now encounter a new problem: how can we distribute a public key if we don't trust any nodes on the network?

# Bootstrapping and Verifying a PKI

Modern Internet based techniques involve a trusted oracle who will distribute certificates guaranteeing that a key is associated with a user. In essence, this is a specialisation of social authentication: my only friend is the oracle and I will trust friends of the oracle but not friends of friends of the oracle. This is impractical in an opportunistic network setting, as it involves (a) trusting a node and (b) every node having contact with the oracle, which considerably restricts the size of the network.

Perhaps the only foolproof method to verify a public key is to physically meet the owner and get them to verify the key. The only user we trust is the owner of the public key (because nothing they do during the verification would allow them to compromise the network). However, our network is designed as a microblogging platform, and we do not want to have to physically meet every person we are interested in.

Lets take a step back and look at the problem in a different light: we are trying to use the opportunistic network to verify that an arbitrary user identifier (i.e. a username chosen by the user) is uniquely associated with an arbitrary (randomly chosen) public key. But is this approach really necessary. Social convention dictates that a person is free to choose their own username. However if a user can choose a specific username then an attacker (or another user with a similar taste in usernames) can also choose the same username (a sybil attack). We can avoid these unnecessary complications simply by creating a username that is dependent on the public key (e.g. a truncated version of the public key). When a node tells us that a specific username is tied to a specific public key, we don't have to trust them - we can check that it is true.

We can extend this argument further by saying that if a username is wholly dependent on the public key then it is inconsequential. A user can be identified by their public key alone. However, real life undermines this beautiful scheme - public keys are too large to pass between people easily. Small, arbitrary usernames can be written down or embedded in a QR code but large public keys are too unwieldy to transfer in physical form and we cannot guarantee that other methods of digital communication are available.

Based on the above logic, we propose the following scheme for verifying messages passed through an opportunistic network:

Users generate a random public/private key pair using 4096-bit RSA. Their username is the base-64 representation of the SHA-256 hash of the public key with some parity bits (a 4 character string - this seems small but the chances of collisions are minute). The public key/username pair can then be distributed throughout the network. Messages sent by the user are signed with their private key.

If I wish to obtain the public key of a user, I must gain their username without using the opportunistic network (in a similar way to obtaining an email address). Once I have this, I can ask other nodes for the associated public key. This request may be obscured by various means such as those described in the SSNR-OSNR paper. I can verify that the public key is indeed related to that username and I can now verify that any message received from that user definitely originated from that user, without ever having to trust a network node.

The main disadvantage of this technique is that users are no longer able to choose meaningful usernames. We believe that this is outweighed by the benefits of having total trust in the network.

# Selfish Nodes

While this scheme is effective at protecting from sybil attacks and message modification, it is unable to protect against selfish nodes which only receive messages and never pass them on. Such nodes can be detected and avoided using algorithms such as IRONMAN. However, because our routing algorithm is dissemination-based, such nodes are unlikely to impact the network so our network will make no attempt to prevent this behaviour.

# Routing Algorithm

Now we come to the problem of routing. Simply put, a routing algorithm takes all available information about a message and uses that information to decide where to send it. In trust based networks, this information is freely available to all trusted nodes (friends lists, recipients, previous paths etc). However, we have opted for a model where all nodes are considered untrustworthy. This means that we must obscure or remove all of this information, while still allowing a routing algorithm to use it.

In our network, the goal is to broadcast messages from a sender to all users interested in messages from that sender (we will ignore the addition of hashtags for now). Pocket switched networks are mobile networks without infrastructure. This means that it is very hard (though not impossible) to use location based or hierarchy based techniques to route messages. There are two main approaches to routing in an infrastructure-less network: dissemination based and context based routing. Dissemination based routing protocols are a form of controlled flooding, where the message is forwarded to any node that may be interested. This tends to create many unnecessary copies of the message, so a good buffer eviction algorithm is needed. Context based protocols have a more discerning approach where limited copies of the message are passed around. Messages sent with this approach tend to take more time to reach the recipient. Our network is a blogging platform where messages are being broadcast to a potentially large number of users. Because context based algorithms limit the number of copies of a message, this approach is unsuited to our needs. For this reason, we will use a dissemination based approach.

Epidemic routing is the simplest and most well known version of dissemination based routing. In this approach, copies of the message are passed to every node that is encountered. While it is the most optimal solution to get a message to the destination it is also the most resource intensive, requiring lots of unnecessary message passing and storage. For this reason we should attempt to use a more selective algorithm.

Burns et al propose a clever location based routing algorithm, the MV (Meeting/Visit) algorithm. This uses knowledge of user location and movements to efficiently forward messages to their destination. This uses static nodes at certain locations to increase the likeliness of a successful transfer. While these static nodes can greatly improve the efficiency of the network, they restrict the network to locations where static nodes are in place. For this reason, we consider the MV algorithm to be unsuitable for our network.

The PROPHET algorithm takes a simpler, probability based approach. Every node stores a probability of being able to forward a message to the recipient. This probability is transitive: if node A is able to forward messages to a recipient and node B regularly meets node A, then node B is also able to forward the message to the recipient. This can be adapted to suit our interest based model where nodes have an interest in receiving messages from a certain user: the probability of being able to forward a message to a recipient is based on how interested the recipient is in the message. The transitive property also holds. We can use the use the SSNR-OSNR algorithm to obscure metadata such as interest lists: By adding random values and encrypting metadata in a bloom filter, we can allow a routing algorithm to determine whether a value is probably in a set of data without revealing the full contents of the set. We can use probability based variants of the bloom filter to allow an approximation of the PROPHET algorithm.

The BUBBLE Rap algorithm is a well known social based algorithm. It works by identifying popular nodes in a community capable of passing messages to other communities. The algorithm attempts to send messages via these popular nodes, as they are more likely to be able to pass the message on to a distant community. While this algorithm has been shown to be more effective that algorithms such as PROPHET, we do not see how it can be adapted to suit the broadcast based model of our network.


# Message Buffer Eviction

When the message buffer is too large, it must evict a message. This message should be the least likely to be used again. The simplest approach is the LRU (Least Recently Used) algorithm. Here, the oldest messages are removed on the assumption that they are probably the most widely distributed.

However, we have better ways of measuring message distribution. Give each message a distribution count initialised to 0. Every time the message is sent or a node is encountered which already has the message, this distribution count is incremented. At eviction time, the message with the highest distribution count is evicted.
