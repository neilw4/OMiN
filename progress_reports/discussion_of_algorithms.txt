# Authentication Models

Authentication is a major issue in opportunistic networks: how can we be sure that a message was sent by a user, and has not been modified.

The simplest option is to forfeit authentication entirely and trust every node to behave correctly. This is possible for small networks, where the distributer of network nodes can trust every user. However, as the network grows, it becomes a statistical certainty that an untrustworthy person has gained access to the network (even if each user is 99.99% trustworthy, a network with 7000 users has a 50% probability of having an untrusted user). Given that our network is designed to be scalable, this option is unfeasible.

Networks which may contain an untrusted user must use measures to prevent this. A common approach is for each user to identify nodes which may be trustworthy or untrustworthy. Social authentication is a common strategy: only 'friends' of users are considered trustworthy. However, for such networks, trust is a transitive property: if I trust my friend and my friend trusts their friend, I must therefore trust the friend of my friend. In real life, this is not always the case. The IRONMAN algorithm takes a different approach by detecting nodes displaying unusual behavior. These nodes are then marked as untrustworthy. However, this can only detect untrustworthy nodes after they have committed a crime. If the attacker is able to control over 50% of the network (as GHash.IO managed with Bitcoin), they can manipulate the network into believing that the attacker is trustworthy and that other nodes are not. This approach of using heuristics to separate trustworthy and untrustworthy nodes is useful, but still susceptible to attack.

In order to completely mitigate the risk of an attacker (or faulty node) becoming a trusted node, there is only one option: don't trust anyone. The only way to verify that a message actually came from a user is to have some token capable of irrefutably proving that a message was sent by a user. The solution is simple: a public key. Users sign a message with their private key, and anyone with their public key can verify that it came from them. So we now encounter a new problem: how can we distribute a public key if we don't trust any nodes on the network?

# Bootstrapping and Verifying a PKI

Modern Internet based techniques involve a trusted oracle who will distribute certificates guaranteeing that a key is associated with a user. In essence, this is a specialisation of social authentication: my only friend is the oracle and I will trust friends of the oracle but not friends of friends of the oracle. This is impractical in an opportunistic network setting, as it involves (a) trusting a node and (b) every node having contact with the oracle, which considerably restricts the size of the network.

Perhaps the only foolproof method to verify a public key is to physically meet the owner and get them to verify the key. The only user we trust is the owner of the public key (because nothing they do during the verification would allow them to compromise the network). However, our network is designed as a microblogging platform, and we do not want to have to physically meet every person we are interested in.

Lets take a step back and look at the problem in a different light: we are trying to use the opportunistic network to verify that an arbitrary user identifier (i.e. a username chosen by the user) is uniquely associated with an arbitrary (randomly chosen) public key. But is this approach really necessary. Social convention dictates that a person is free to choose their own username. However if a user can choose a specific username then an attacker (or another user with a similar taste in usernames) can also choose the same username (a sybil attack). We can avoid these unnecessary complications simply by creating a username that is dependent on the public key (e.g. a truncated version of the public key). When a node tells us that a specific username is tied to a specific public key, we don't have to trust them - we can check that it is true.

We can extend this argument further by saying that if a username is wholly dependent on the public key then it is inconsequential. A user can be identified by their public key alone. However, real life undermines this beautiful scheme - public keys are too large to pass between people easily. Small, arbitrary usernames can be written down or embedded in a QR code but large public keys are too unwieldy to transfer in physical form and we cannot guarantee that other methods of digital communication are available.

Based on the above logic, I propose the following scheme for verifying messages passed through an opportunistic network:

Users generate a random public/private key pair using 4096-bit RSA. Their username is the base-64 representation of the last 128 bits of the public key (a 2 character string - this seems small but the chances of collisions are minute). The public key/username pair can then be distributed throughout the network. Messages sent by the user are signed with their private key.

If I wish to obtain the public key of a user, I must gain their username without using the opportunistic network (in a similar way to obtaining an email address). Once I have this, I can ask other nodes for the associated public key. This request may be obscured by various means such as those described in the SSNR-OSNR paper. I can verify that the public key is indeed related to that username and I can now verify that any message received from that user definitely originated from that user, without ever having to trust a network node.

The main disadvantage of this technique is that users are no longer able to choose meaningful usernames. I believe that this is outweighed by the benefits of having total trust in the network.

# Selfish Nodes

While this scheme is effective at protecting from sybil attacks and message modification, it is unable to protect against selfish nodes which only receive messages and never pass them on. Such nodes can be detected and avoided using algorithms such as IRONMAN. However, because our routing algorithm is dissemination-based, such nodes are unlikely to impact the network so our network will make no attempt to revent this behaviour.

# Routing Algorithm

Now we come to the problem of routing. Simply put, a routing algorithm takes all available information about a message and uses that information to decide where to send it. In trust based networks, this information is freely available to all trusted nodes (friends lists, recipients, previous path...). However, we have opted for a model where all nodes are considered untrustworthy. This means that we must obscure or remove all of this information, while still allowing a routing algorithm to use it. I have chosen to use the SSNR-OSNR algorithm to do this. By adding random values and encrypting metadata in a bloom filter, we can allow a routing algorithm to determine whether a value is probably in a set of data without revealing the full contents of the set.

In our network, the goal is to broadcast messages from a sender to all users interested in messages from that sender (we will ignore the addition of hashtags for now). Pocket switched networks are mobile networks without infrastructure. This means that it is very hard (though not impossible) to use location based or hierarchy based techniques to route messages. There are two main approaches to routing in an infrastructure-less network: dissemination based and context based routing. Dissemination based routing protocols are a form of controlled flooding, where the message is forwarded to any node that may be interested. This tends to create many unnecessary copies of the message, so a good buffer eviction algorithm is needed. Context based protocols have a more discerning approach where limited copies of the message are passed around. Messages sent with this approach tend to take more time to reach the recipient. Our network is a blogging platform where messages are being broadcast to a potentially large number of users. Because context based algorithms limit the number of copies of a message, this approach is unsuited to our needs. For this reason, we will use a dissemination based approach.

...