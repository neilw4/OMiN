\documentclass{article}
%Gummi|065|=)
\title{\textbf{Specification of SH project: Opportunistic Microblogging Network}}
\author{Neil Wells\\
\texttt{ndw@st-andrews.ac.uk}}
\date{}
\begin{document}

\maketitle

\section*{Summary}
This document details a secure microblogging platform using a pocket switched, opportunistic network of smartphones. Users can register interest in messages from other users or messages containing certain hashtags, and the network will attempt to deliver messages from the sender to the reciever in a secure and efficient manner, while revealing as little metadata as possible.


\section*{Terminology}
A \textbf{node} is any device capable of storing and forwarding messages. It does not have to be a user. For example, a public transport vehicle would make an ideal node because it will encounter lots of users.

A \textbf{user} is any node with a username and encryption key, allowing them to send and recieve messages.

A \textbf{message} is a text-based microblog post broadcasted from a user to all interested users.

A \textbf{direct message} is a message sent to a single user. It is encrypted so only that user can read it.

Two nodes make a \textbf{connection} when they are in close proximity to each other and have established a communication channel.

\section*{Users}
A user's data consists of:
\begin{itemize}
\item An RSA 4096 bit public/private key pair for asymetric encryption.
\item A unique username.
\item A friends list of users to follow.
\item A list of hashtags to follow.
\end{itemize}

\section*{Messages}
Messages consist of a sender, a message id and message contents.

The sender takes the form of a username, and the message contents is a string.

The message id is used to verify that the message has not been modified. It consists of SHA-256 hash of the message contents, plus the date and time that the message was sent in ISO-8601 format, all encrypted with the senders private key. All users with the senders public key can then verify the message. If the message is unverifiable, it is discarded and the sender is notified via a secure direct message.

Secure direct messaging is implemented by encrypting the message contents with the public key of the reciever and adding the hashtag \#to\_\textless username\textgreater.

Nodes will store a finite number of messages. Nodes will also store a distribution count. This is incremented when the message is sent to another node or another node indicates that it it already has the message. When a message is to be evicted to make space, the most distributed message will be removed.

Nodes may use a large bloom filter or similar construct to record that a message has been seen even if it has been deleted.


\section*{Routing algorithm}
Every user, $u$ has a list, $I(u)$, of interests. Interests include people they would like to recieve messages from (in the form of their username), hashtags (in the form \#tag), and messages mentioning a certain user (in the form \#to\_user). This will, by default, incude messages mentioning the user $u$.

The routing algorithm must encode the interests in such a way that they cannot be reverse engineered, and include the interests of recently encountered nodes (as there is a higher probability of encountering them soon).

Every node also has a record, $R(u)$, of interests of people they have recently met. This is stored in the form of a stable bloom filter (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.1569), which is designed to evict old entries.

It may be possible to find a better heuristic to predict which users a node should relay messages for.

We may use a modified form of the stable bloom filter where the total of all of the filter cells is unable to exceed some maximum value. If it is exceeded, then all of the cell values are decremented until the maximum value is no longer exceeded. This provides the benefit of requiring no additional randomness and should allow bloom filters to be added together without affecting the properties of the cumulative bloom filter.

These can all be combined to create a bloom filter, $B(u)$, containing interests that the node would like to recieve messages about (both to read and to pass on). $B(u)$ is calculated by adding $SO(I(u))$ - the SSNR-OSNR (http://www.sciencedirect.com/science/article/pii/S0140366410004767 without the salt) of $I(u)$ - and $R(u)$.

$B(u)$ now forms a reasonable approximation of what messages a node should accept, without revealing $I(u)$ (and, for extra security, the username) for any user.

When two nodes make a connection, one of them takes on the role of a server, $u_s$, and the other becomes a client $u_c$. $u_c$ sends $B(u_c)$ to $u_s$. $u_s$ incorporates $B(u_c)$ into $R(u_s)$. It then usese $B(u_c)$ to figure out which messages may be of interest. It sends the list of message ids to $u_c$, which then requests the messages that it doesn't already have.

Once the exchange has finished, they switch roles so $u_c$ becomes the server and $u_s$ becomes the client, and the process is repeated.
 

\section*{Building and maintaining a friends list}
A friends list consists of the usernames and public keys of people that a user would like to recieve messages from.

When a user adds X to a friends list, they can immediately add X to their interests list. At this point, while they can recieve messages from X, they do not have Xs public key and therefore they cannot verify the authenticity of the messages, or send encrypted direct messages.

When other nodes are encountered, the user will ask for the public key of X. This continues until it gets the public key of X. The user will continue to occasionally ask for the public key of X to verify its credibility. To disguise this, users will use a variant of SSNR (as described in http://www.sciencedirect.com/science/article/pii/S0140366410004767) by ocasionally also asking for the public key of random users.
 
Some nodes are not users. They may still build and maintain a friends list to allow distribution of public keys. They should find the public keys of senders of messages.
 
If a node detects that a user has multiple public keys, then multiple people must have picked the same username, either by accident or design. The node should send an encrypted direct message to notify all affected users (if it is a user capable of sending messages), and continue to use whichever public key is most popular.

\section*{Connection protocol}
TBA. HTTPS?

\end{document}