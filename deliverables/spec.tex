\documentclass{article}
%Gummi|065|=)
\title{\textbf{Specification of SH project: Opportunistic Microblogging Network}}
\author{Neil Wells\\
\texttt{ndw@st-andrews.ac.uk}}
\date{}
\begin{document}

\maketitle

\section*{Summary}
This document details a secure microblogging platform using a pocket switched, opportunistic network of smartphones. Users can register interest in messages from other users or messages containing certain hashtags, and the network will attempt to deliver messages from the sender to the reciever in a secure and efficient manner, while revealing as little metadata as possible.


\section*{Terminology}
A node is any device capable of storing and forwarding messages. It does not have to be a user. For example, a public transport vehicle would make an ideal node because it will encounter lots of users.

A user is any node with a username and encryption key capable of sending and recieving messages.

A message is a text-based microblog broadcasted from a user to all interested users.

\section*{Users}
A user's data consists of:
\begin{itemize}
\item An RSA 4096 bit public/private key pair for asymetric encryption.
\item A unique username which will be linked to a user's public key.
\item A (hidden) list of users (and their public keys) to follow.
\end{itemize}

\section*{Messages}
Messages are encoded in JSON format (some other, more concise, formats such as protocol buffers may be considered in the future). They consist of a sender, a message id and message contents.

The sender takes the form of a username, and the message contents is a string.

The message id is used to verify that the message is intact, was sent from the user it says it was, and that it has not been modified. It consists of SHA-256 hash of the message contents, plus the date and time that the message was sent in ISO-8601 format, all encrypted with the senders private key. All users with the senders public key can then verify the message. If the message is unverifiable, it is discarded and the sender is notified via a secure direct message.

Secure direct messaging is implemented by encrypting the message contents with the public key of the reciever.

Nodes will store a finite number of messages. Nodes will also store a distribution count. This is incremented when the message is sent to another node or another node indicates that it it already has the message. When a message is to be evicted to make space, the most distributed message will be removed.

Nodes may use a large bloom filter or similar construct to record that a message has been seen even if it has been deleted.

\section*{Routing algorithm}
Every user has a list, F, of interests. Interests include people they would like to recieve messages from (in the form of their username), hashtags (in the form \#tag), and messages mentioning a certain user (in the form @user). This will, by default, incude messages mentioning the user.

The goal of this routing algorithm is to encode the interests in such a way that they cannot be reverse engineered, and to include the interests of recently encountered nodes (as there is a higher probability of encountering them soon).

Every node also has a record, R, of interests of people they have recently met. This is stored in the form of a stable bloom filter (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.1569), which is designed to evict old entries.

It may be possible to find a better heuristic to predict which users a node should relay messages for.

We may use a modified form of the stable bloom filter where the total of all of the filter cells is unable to exceed some maximum value. If it is exceeded, then all of the cell values are decremented until the maximum value is no longer exceeded. This provides the benefit of requiring no randomness and should allow bloom filters to be added together without affecting the properties of the cumulative bloom filter.

These can all be combined to create a bloom filter, I, containing interests that the node would like to recieve messages about (both to read and to pass on). I is calculated by adding SO(F), the SSNR-OSNR (http://www.sciencedirect.com/science/article/pii/S0140366410004767 without the salt) of F and B(R), R converted into a normal bloom filter.

I now forms a reasonable approximation of what messages a node should accept, without revealing F (and, for extra security, the username) for any user.

When two nodes meet, they can exchange their I filters, and then exchange all relevant messages. They combine each others I filters wth their R filters, recording that, because they have recently met, they are likely to meet again.

\section*{Building and maintaining a friends list}
A friends list consists of the usernames and public keys of people that a user would like to recieve messages from.

When a user adds X to a friends list, they can immediately add X to their interests list. At this point, while they can recieve messages from X, they do not have Xs public key and therefore they cannot verify the authenticity of the messages, or send encrypted direct messages.

When other nodes are encountered, the user will ask for the public key of X. This continues until it gets the public key of X. The user will continue to occasionally ask for the public key of X to verify its credibility. To disguise this, users will use a variant of SSNR (as described in http://www.sciencedirect.com/science/article/pii/S0140366410004767) by ocasionally also asking for the public key of random users.
 
Some nodes are not users. They may still build and maintain a friends list to allow distribution of public keys. They should find the public keys of senders of messages.
 
If a node detects that a user has multiple public keys, then multiple people must have picked the same username, either by accident or design. The node should send an encrypted direct message to notify all affected users (if it is a user capable of sending messages), and continue to use whichever public key is most popular.

\section*{Connection protocol}
TBA. HTTPS?

\end{document}